package generator

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/printer"
	"io/ioutil"
)

// File define a parsed file.
type file struct {
	pkg  *Package
	ast  *ast.File
	name string
	dir  string
}

func (f *file) generateContent(release bool) (content []byte, err error) {
	buf := bytes.Buffer{}
	buf.WriteString("// Code generated by Debuggo. DO NOT EDIT.\n\n")

	if release {
		buf.WriteString("\n// +build !" + f.pkg.name + "\n\n")
		err = f.generateReleaseContent(&buf)
	} else {
		buf.WriteString("\n// +build " + f.pkg.name + "\n\n")
		err = f.generateDebugContent(&buf)
	}

	// Generate and format
	if err != nil {
		return buf.Bytes(), err
	}

	content, err = format.Source(buf.Bytes())
	if err != nil {
		return content, err
	}

	return
}

func (f *file) generateDebugContent(buf *bytes.Buffer) error {
	// Just copy source file
	path := f.dir + "/" + f.name
	src, err := ioutil.ReadFile(path)
	if err != nil {
		return err
	}

	buf.Write(src)

	return nil
}

func (f *file) generateReleaseContent(buf *bytes.Buffer) error {
	parser := newParser()
	parser.parse(f.ast)

	printer.Fprint(buf, f.pkg.fset, f.ast)

	return nil
}

// return the signature of a declaration expression
// func declToString(e ast.Expr) string {
// 	switch expr := e.(type) {
// 	case *ast.Ellipsis:
// 		subType := declToString(expr.Elt)
// 		return fmt.Sprintf("...%s", subType)

// 	case *ast.InterfaceType:
// 		fNames := fmtFieldList("%v%v", expr.Methods.List)
// 		return fmt.Sprintf("interface{%v}", strings.Join(fNames, "\n"))

// 	case *ast.SelectorExpr:
// 		return fmt.Sprintf("%v.%v", expr.X, expr.Sel)

// 	case *ast.FuncType:
// 		p := []string{}
// 		if expr.Params != nil && expr.Params.List != nil {
// 			p = fmtFieldList("%v %v", expr.Params.List)
// 		}

// 		params := strings.Join(p, ", ")

// 		r := []string{}
// 		if expr.Results != nil && expr.Results.List != nil {
// 			r = fmtFieldList("%v %v", expr.Results.List)
// 		}

// 		results := ""
// 		if len := len(r); len != 0 {
// 			results = r[0]
// 			if len > 1 {
// 				results = fmt.Sprintf("(%v)", strings.Join(r, ", "))
// 			}
// 		}

// 		return fmt.Sprintf("(%v) %v", params, results)

// 	case *ast.ArrayType:
// 		arrType := declToString(expr.Elt)
// 		len := ""
// 		// Array size (len is nil for slices)
// 		if expr.Len != nil {
// 			ident, ok := expr.Len.(*ast.Ident)
// 			if ok {
// 				decl := ident.Obj.Decl.(*ast.ValueSpec)
// 				lit := decl.Values[0].(*ast.BasicLit)
// 				len = fmt.Sprint(lit.Value)
// 			}

// 			// Literal
// 			lit, ok := expr.Len.(*ast.BasicLit)
// 			if ok {
// 				len = lit.Value
// 			}
// 		}

// 		return fmt.Sprintf("[%v]%v", len, arrType)

// 	// primitive
// 	default:
// 		return fmt.Sprint(expr)
// 	}
// }

// func getNamesFromField(field *ast.Field) (names []string, fType string) {
// 	fType = fmt.Sprint(field.Type)

// 	for _, name := range field.Names {
// 		names = append(names, name.Name)
// 	}

// 	return
// }

// func parseFunc(fnType ast.FuncType) (debugFunc string) {
// 	p := []string{}
// 	if fnType.Params != nil && fnType.Params.List != nil {
// 		// p = fmtFieldList("%v %v", fnType.Params.List)
// 	}

// 	params := strings.Join(p, ", ")

// 	r := []string{}
// 	if fnType.Results != nil && fnType.Results.List != nil {
// 		r = fmtFieldList("%v %v", fnType.Results.List)
// 	}

// 	results := ""
// 	if len := len(r); len != 0 {
// 		results = r[0]
// 		if len > 1 {
// 			results = fmt.Sprintf("(%v)", strings.Join(r, ", "))
// 		}
// 	}

// 	return fmt.Sprintf("(%v) %v", params, results)

// 	return
// }
